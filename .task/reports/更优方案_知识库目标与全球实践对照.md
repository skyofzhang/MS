# 更优方案：知识库目标与全球实践对照

**依据**：知识库 V3.0 总控与 AI 开发知识库中的目标与诉求 + 全球联网检索的 2024–2025 实践  
**目的**：在「不背离现有架构」的前提下，给出可落地的更优方案与优先级。

---

## 一、知识库中的目标与诉求（摘要）

以下直接来自 Notion 知识库 V3.0 与 AI 开发知识库，作为方案对齐的基准。

| 维度 | 内容 |
|------|------|
| **业务目标** | 每月量产 5–10 款小游戏；平台：抖音小游戏、Android、iOS |
| **团队规模** | team: 3 |
| **核心原则** | 面向对象是 AI 不是人类；Cursor/Claude 是知识库唯一大脑；人类是物理限制突破助手；扁平化 ≤2 级可达 |
| **工程规范** | WHEN-DO-VERIFY 指令；JSON + 代码 + Mermaid；禁止主观词汇；FORBIDDEN 系列（占位符、硬编码、跳过验证等） |
| **验收标准** | §6 完成检查：编译 0 Error、PlayMode 可进、视觉自测 VC-001～008、核心循环可体验、APK 可构建 |
| **当前阶段** | Phase 5 已完成；P0/P1 100%；85 个文件已实现 |

因此，更优方案需同时满足：**量产能力**、**AI 为第一执行者**、**人类仅关键点介入**、**知识库为单一事实源**、**编译/构建/验收可自动闭环**。

---

## 二、全球实践检索要点（含来源）

### 2.1 多智能体与自动化触发

- **Cursor 2.0**：支持最多 **8 个并行 AI Agent**（Git worktrees 隔离），通过 Webhook 与「项目经理 AI」做任务排序，实现**自动协调**（非仅人工切角色）。  
  [Building Autonomous Multi-Agent Systems with Cursor 2.0](https://medium.com/@abhishek97.edu/building-autonomous-multi-agent-systems-with-cursor-2.0-from-manual-to-fully-automated-04397c1831af)

- **Claude 程序化触发**：Anthropic 提供 **headless/非交互** 调用方式，可将 Claude 嵌入 CI/CD 或编排器：  
  `claude -p "任务描述" --allowedTools Read,Edit,Bash`，配合 `--output-format` 等做结构化输出。  
  [Run Claude Code programmatically](https://docs.anthropic.com/en/docs/claude-code/headless)

- **n8n AI Agent**：支持 Webhook 触发、多智能体编排、RAG、人机回环；**Respond to Webhook** 可实现「n8n 调外部 API → 外部回调 n8n」的双向闭环。  
  [n8n AI agent builder](https://n8n.io/ai-agents)、[The Ultimate Guide to AI Agent Architectures — With Practical n8n Examples](https://medium.com/@deepakkamboj/the-ultimate-guide-to-ai-agent-architectures-with-practical-n8n-examples-6d17001b8176)

### 2.2 知识库驱动与单一事实源

- **时序/状态与知识库**：用**有限状态机（FSM）** 管理推理阶段，并对接外部知识库；人类可对**单个模块**做过程反馈，便于与你们的「状态机 + .task」对齐。  
  [Temporal Agents with Knowledge Graphs | OpenAI Cookbook](https://cookbook.openai.com/examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents_with_knowledge_graphs)、AMOR 等框架。

- **单一事实源**：知识库作为 AI 决策的权威来源；建议增加「运行时契约层」（由 Notion 或同步脚本生成的一份 JSON/YAML），供 Claude、Cursor、n8n 共用，减少漂移。  
  （综合多篇 KB-driven development 与 agent 架构论述。）

### 2.3 Unity 构建与编译错误闭环

- **GameCI**：**game-ci/unity-builder**、**unity-test-runner** 在 **GitHub Actions** 上跑 Unity 无头构建与测试（含 Linux 容器），每次 push 可自动编译+测试；构建结果与日志可作为 artifact，供后续「失败时触发修复」使用。  
  [Builder | GameCI](https://game.ci/docs/github/builder)、[Getting started - GameCI](https://game.ci/docs/github/getting-started)

- **CI 失败自动修复**：OpenAI Codex 等方案将「CI 失败日志」交给 AI 自动修；同理可把 **Unity 编译/构建失败** 的 log 或 `.task/build_errors.json` 交给 Claude 非交互执行修复。  
  [Auto-fix CI failures with Codex](https://developers.openai.com/codex/guides/autofix-ci/)

### 2.4 小游戏量产与模板

- **Cocos 等引擎**：通过 **build-templates + 平台配置 JSON** 实现多平台、多款小游戏的**模板化构建**；一次模板可复用到多项目。  
  与你们知识库中的 **RULE-RES 表 + 项目常量** 思路一致：同一套结构、不同资源与配置即可衍生多款。

- **集中配置与规则**：团队级 AI 开发建议**共享 Cursor 规则库**、**版本化 MCP 服务**、与 **CI/CD/代码评审** 打通。  
  [Team Collaboration: Scaling AI-Powered Development](https://developertoolkit.ai/en/cursor-ide/advanced-techniques/team-collaboration/)

---

## 三、更优方案（与目标逐条对应）

### 方案 A：需求与编译错误「自动触发 Claude」——去掉「人类说开始」

**目标对应**：AI 为唯一大脑、人类仅物理限制突破、闭环自动化。

**做法**：

1. **NWF-01（Notion 新需求）**  
   n8n 在检测到新需求后，**不再只写状态**，而是增加一步：**调用 Claude 非交互执行**。  
   - 若 n8n 跑在可执行 shell 的节点上：执行 `claude -p "读取 .task/workflow_state.json 与 Notion 需求页，执行下一阶段（planning）" --allowedTools Read,Edit,Bash`，并传入项目路径或 repo 信息。  
   - 若 n8n 无法直接跑本机 CLI：改为 n8n 调用一台「始终在线」的轻量 runner（腾讯云/本地均可），由该 runner 执行 Claude CLI；或使用 **Anthropic Agent SDK** 在自有服务中跑 Claude，n8n 通过 HTTP 触发该服务。

2. **NWF-05（编译错误）**  
   Unity `BuildErrorReporter` 已 POST 到 `/webhook/build-error` 并写 `.task/build_errors.json`。  
   NWF-05 在收到 webhook 后增加**下游**：  
   - 将 body（或从 repo 拉取的 `build_errors.json`）作为上下文，  
   - 调用同上「Claude 非交互」入口，提示词例如：「根据 .task/build_errors.json 修复 MoShou 项目编译错误，只改代码，不改场景。完成后写 task_result 并 push [FIX]。」  
   这样**编译错误 → n8n → Claude 修 → push** 形成闭环，无需人类说「开始修」。

**参考**：  
[Run Claude Code programmatically](https://docs.anthropic.com/en/docs/claude-code/headless)、  
[n8n AI agent builder](https://n8n.io/ai-agents)、  
[The Ultimate Guide to AI Agent Architectures — With Practical n8n Examples](https://medium.com/@deepakkamboj/the-ultimate-guide-to-ai-agent-architectures-with-practical-n8n-examples-6d17001b8176)

---

### 方案 B：Unity 构建与测试进 GitHub Actions（GameCI）——云端可重复、可追溯

**目标对应**：验收标准中的「编译 0 Error、APK 可构建」、以及「稳定开发环境」。

**做法**：

1. 在仓库中增加 **.github/workflows/unity.yml**（或类似）：  
   - `actions/checkout`（含 LFS 若需要）  
   - `actions/cache` 缓存 Unity Library  
   - `game-ci/unity-test-runner@v4` 跑测试  
   - `game-ci/unity-builder@v4` 指定 `targetPlatform: Android`（与你们现有 BuildScript 目标一致）  
   - `actions/upload-artifact` 上传 APK 与 build.log  

2. 配置 **Unity 许可证**：通过 GitHub Secrets 注入 `UNITY_LICENSE` 或 `UNITY_EMAIL`/`UNITY_PASSWORD`（按你们许可证类型选 GameCI 文档中的方式）。

3. **与 n8n 的衔接（可选）**：  
   - 若构建失败：在 workflow 末尾用 `curl` 调 n8n 的 **build-error** 或专用「CI 失败」webhook，传入 `workflow_run` 的 log 或 artifact 链接。  
   - 这样「云端构建失败 → n8n → Claude 修」与现有 NWF-05 思路一致，只是多了一个「权威的构建结果」来源。

**效果**：每次 push 都有一次可复现的编译+测试+构建；人类/Claude 均可从 Actions 页查看结果，符合「扁平化、可验证」原则。

**参考**：  
[Builder | GameCI](https://game.ci/docs/github/builder)、  
[Setting up a CI/CD build pipeline for Unity using GitHub Actions](https://www.anchorpoint.app/blog/setting-up-a-ci-cd-build-pipeline-for-unity-using-github-actions)

---

### 方案 C：知识库「运行时契约层」——单一事实源、减少漂移

**目标对应**：知识库为 AI 唯一大脑、WHEN-DO-VERIFY 可执行、禁止硬编码路径。

**做法**：

1. **从 Notion 生成一份「运行时契约」**（单文件或少量文件）：  
   - 内容：§1 项目常量、§2 RULE-RES 路径表、§3 系统调用约定、§4 数值常量、§5 物理层、§6 完成检查清单。  
   - 格式：JSON 或 YAML，便于程序与 AI 解析。  
   - 放置：例如 `.task/kb_contract.json` 或 `MoShou/Assets/Resources/Configs/kb_contract.json`，并加入版本/更新时间。

2. **生成方式二选一**：  
   - **人工/半自动**：Notion 导出或复制到脚本，脚本转成契约 JSON，提交到 repo。  
   - **自动**：定时或 Notion 变更时，用 Notion API 拉取对应页面，用脚本生成契约并 push（可由 n8n 调度）。

3. **使用方式**：  
   - Claude/Cursor 的「第一步」读取该契约，再写代码或改场景，避免依赖过期的 .task 缓存或各说各的路径。  
   - ResourceLoader、BuildErrorReporter、SceneModifier 等可优先从契约读路径与常量（若你们希望代码与知识库强一致）。  
   - n8n 在组 payload 时也可引用契约中的 task 模板、阶段列表，保证与状态机一致。

**效果**：Notion 仍是唯一事实源，契约是其「可执行镜像」；AI 与自动化都读同一份，符合「扁平化 ≤2 级可达」和「禁止硬编码路径」。

**参考**：  
[Temporal Agents with Knowledge Graphs](https://cookbook.openai.com/examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents_with_knowledge_graphs)、  
知识库 §2 RULE-RES 与 §1 项目常量。

---

### 方案 D：量产 5–10 款/月——模板流水线 + 多项目编排

**目标对应**：每月量产 5–10 款小游戏、team: 3。

**做法**：

1. **黄金模板仓库**：  
   - 将当前 MS/MoShou 抽成「模板」：保留脚本结构、RULE-RES 目录结构、.task 协议、BuildScript、知识库契约生成逻辑；资源用占位或最小集。  
   - 新游戏 = 从模板 fork 或 copy + 新 Notion 页（或知识库子区）描述该游戏差异（主题、关卡、美术 key 等）。

2. **流水线统一**：  
   - 每款游戏仍走同一套：Notion 需求 → n8n → Claude planning → task_assign → cursor_execute（或 Claude+Unity CLI）→ 验收 → build。  
   - 差异仅：`current_task.json`、`workflow_state.json`、以及每款的 Notion 页/契约 slice。n8n 的「项目上下文」可用 repo 名或 `.task/project_code.json` 区分。

3. **并行与分工**：  
   - Cursor 2.0 支持多 Agent + Git worktrees；可考虑「1 个 worktree = 1 款游戏」，由 n8n 或 Claude 分配任务到不同 repo/branch，实现多款并行开发。  
   - 人类 3 人：1 人负责需求与验收、1 人负责模板与知识库维护、1 人负责 n8n/Claude/CI 运维，与「人类仅关键点介入」一致。

4. **资源与配置**：  
   - 美术资源库（如 ai-resources）按游戏/项目分目录；RULE-RES 表在契约中按项目可微调路径或前缀。  
   - 与 Cocos 等「build-templates + 多平台 JSON」思路一致：同一套流水线，多份配置与资源。

**效果**：单款流程跑通后，复制「模板 + Notion 页 + 资源目录」即可扩展款数；规模化依赖 n8n/Claude 的触发稳定性和 GameCI 的并行能力。

**参考**：  
[Multi-Agent Coding: Parallel Development Guide](https://www.digitalapplied.com/blog/multi-agent-coding-parallel-development)、  
Cocos 自定义构建模板与多平台配置、  
知识库 GIT_RESOURCE_REPO / projects/moshou 思路。

---

### 方案 E：架构文档与触发约定「合一」——消除双轨

**目标对应**：扁平化、AI 为唯一大脑、人类仅 3 处介入。

**做法**：

1. 在 **CLAUDE_CONTEXT.md** 或 **PROTOCOL.json** 同目录下，新增/合并一份 **「MS 自动化协议 V2」**（或直接更新 PROTOCOL 到 2.0）：  
   - **触发**：明确写「Claude 由 n8n 触发（NWF-01 需求、NWF-05 编译错误）；人类仅在：提需求、资源准备、体验验收」。  
   - **执行**：写清「cursor_execute 阶段由 Cursor 执行（人类打开 Cursor 时）或由 Claude 通过 Unity CLI + SceneModifier 执行（未来可全自动）」；当前采用混合模式，以 .task 为准。  
   - **构建与测试**：写清「Unity 构建与测试可在本地 PowerShell 或 GitHub Actions（GameCI）执行；若启用 Actions，则 push 即触发，失败可触发 NWF-05 或专用 webhook」。  

2. **STATE_MACHINE.md** 与 **WORKFLOW_CORRECTED.md**：  
   - 合并为「状态机 + 执行者约定」单页，或保留两份但在 V2 协议中明确「以 STATE_MACHINE 状态为准，以 V2 协议中的执行者与触发为准」，避免 Cursor 在环内/环外说法打架。

**效果**：Claude、Cursor、人类、n8n 都看同一份约定，减少「听哪份文档」的歧义，符合知识库「禁止主观、结构清晰」的原则。

---

### 方案 F（可选）：MCP 暴露知识库——Cursor/Claude 同源查

**目标对应**：知识库唯一大脑、减少缓存过期。

**做法**：  
用 **Model Context Protocol (MCP)** 搭建一个「Notion 知识库」服务器：对 Cursor 与 Claude 暴露「按页/按块查询」的 tool，使两者在需要时直接查 Notion（或从 Notion 同步后的只读存储），而不是依赖 .task 下的一次性导出。  
Cursor 已支持 MCP；Claude Code 可通过工具调用同一 MCP。  
**收益**：始终读最新知识库；**成本**：需维护 MCP 服务与 Notion API/同步逻辑。可作为在「契约层」稳定后的增强。

**参考**：  
[Team Collaboration: Scaling AI-Powered Development](https://developertoolkit.ai/en/cursor-ide/advanced-techniques/team-collaboration/)

---

## 四、优先级与落地顺序建议

| 优先级 | 方案 | 目标直接对应 | 实施成本 | 建议顺序 |
|--------|------|----------------|----------|----------|
| P0 | **A：n8n 自动触发 Claude（需求 + 编译错误）** | 人类仅关键点介入、编译闭环 | 中（需 runner 或 SDK） | 1 |
| P0 | **E：架构文档合一（V2 协议）** | 扁平化、无歧义 | 低 | 1（可与 A 并行） |
| P1 | **B：GameCI 入 GitHub Actions** | 稳定环境、可重复构建 | 中（许可证与 yml） | 2 |
| P1 | **NWF-05 下游补全**（即使不做 A，也先写清「n8n 收 webhook 后写 .task 或调谁」） | 编译错误闭环 | 低 | 2 |
| P2 | **C：运行时契约层** | 单一事实源、禁止硬编码 | 中（生成脚本+流程） | 3 |
| P2 | **D：模板 + 多项目流水线** | 每月 5–10 款 | 高（模板裁剪+编排） | 4 |
| P3 | **F：MCP 知识库** | 知识库实时性 | 中高 | 5 |

---

## 五、总结

- 知识库中的**目标**（每月量产 5–10 款、AI 为唯一大脑、人类仅 3 处介入、WHEN-DO-VERIFY、验收标准）与当前**全球实践**（Claude 非交互、n8n 编排、GameCI、多 Agent 并行、知识库/契约为单一事实源）是**可对齐**的。  
- **更优方案**的核心是：  
  1. **自动触发**：n8n 直接或间接调用 Claude，去掉「人类说开始」；  
  2. **构建与错误闭环**：Unity 进 GitHub Actions（GameCI），并与 n8n/Claude 打通；  
  3. **单一事实源**：契约层 + 可选 MCP，让知识库可执行、可查；  
  4. **量产**：模板 + 多项目共用同一流水线。  
- 建议先做 **A（触发闭环）+ E（文档合一）**，再补 **B（GameCI）与 NWF-05 下游**，然后视产能需求做 **C 与 D**。这样在不推翻现有架构的前提下，逐步逼近「每月 5–10 款、AI 为主、人类仅关键点」的目标。

---

**报告中的外部链接仅供参考，具体实现请以各产品当前文档为准。**
